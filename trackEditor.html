<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Track Editor for F1 Sim</title>
  <style>
    body {
      margin: 0;
      font-family: Arial;
      background: #222;
      color: white;
    }

    #canvas {
      border: 1px solid #fff;
      cursor: crosshair;
      display: block;
      margin: 10px auto;
      background: #000;
    }

    #controls {
      text-align: center;
      margin: 10px;
    }

    button {
      padding: 10px 20px;
      margin: 5px;
      background: #ff4400;
      color: white;
      border: none;
      cursor: pointer;
    }

    button.active {
      background: #44ff00;
      color: black;
    }

    button.secondary {
      background: #4444ff;
    }

    #export {
      background: #44ff00;
      color: black;
      font-family: monospace;
    }

    #output {
      width: 100%;
      height: 200px;
      margin-top: 10px;
      font-family: monospace;
      background: #111;
      color: #0f0;
      padding: 10px;
    }

    #saveInput {
      padding: 5px;
      margin-left: 10px;
    }

    .control-group {
      display: inline-block;
      margin-left: 20px;
      border-left: 1px solid #555;
      padding-left: 20px;
    }

    .control-group button {
      width: 100px;
      padding: 8px 15px;
      margin: 5px;
    }

    .status-bar {
      text-align: center;
      margin: 10px;
      padding: 10px;
      background: #333;
      border-radius: 5px;
    }

    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 3px;
      pointer-events: none;
      z-index: 1000;
    }
  </style>
</head>

<body>
  <h1 style="text-align: center;">F1 Track Editor</h1>
  <p style="text-align: center;">
    <strong>Tools:</strong> Add Points | Edit Points | Pan View | Delete Points<br>
    <strong>Controls:</strong> Drag points to edit • Right-click to delete • Mouse wheel to zoom • Middle-click to pan
  </p>

  <div class="status-bar" id="status">
    Points: 0 | Mode: Add Points | Zoom: 1.0x | Smoothing: Enabled
  </div>

  <canvas id="canvas" width="1000" height="700"></canvas>

  <div id="controls">
    <!-- Mode Controls -->
    <button id="addBtn" class="active" onclick="setMode('add')">Add Points</button>
    <button id="editBtn" onclick="setMode('edit')">Edit Points</button>
    <button id="panBtn" onclick="setMode('pan')">Pan View</button>
    <button id="deleteBtn" onclick="setMode('delete')">Delete Points</button>

    <!-- Track Operations -->
    <button onclick="clearPoints()">Clear All</button>
    <button onclick="exportPoints()">Export Track</button>
    <button onclick="smoothTrack()">Smooth Corners</button>

    <!-- View Controls -->
    <div class="control-group">
      <button onclick="zoom(1.2)">Zoom In +</button>
      <button onclick="zoom(1/1.2)">Zoom Out -</button>
      <button onclick="resetView()">Reset View</button>
    </div>

    <!-- Track Management -->
    <div class="control-group">
      <input type="text" id="saveInput" placeholder="Enter Track Name" value="Custom Track 1">
      <button onclick="saveTrack()">Save Track</button>
      <button onclick="loadTrackList()">Refresh Tracks</button>
      <select id="loadSelect" onchange="loadSelectedTrack()">
        <option value="">Select Track...</option>
      </select>
    </div>

    <!-- Track Settings -->
    <div class="control-group">
      <label>
        <input type="checkbox" id="smoothingToggle" checked onchange="toggleSmoothing()">
        Real-time Smoothing
      </label>
      <label>
        <input type="checkbox" id="snapToggle" onchange="toggleSnap()">
        Snap to Grid
      </label>
    </div>
  </div>

  <textarea id="output" readonly placeholder="Exported code will appear here..."></textarea>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let scale = 4;
    let offsetX = canvas.width / 2;
    let offsetY = canvas.height / 2;
    let panStartX = 0;
    let panStartY = 0;
    let isPanning = false;

    let points = [];
    let draggingIndex = -1;
    let isDragging = false;
    let mode = 'add';
    let enableSmoothing = true;
    let enableSnap = false;
    let smoothedPoints = [];

    // Tooltip element
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);

    // --- VIEW CONTROLS ---
    function zoom(factor) {
      scale = Math.max(0.1, Math.min(scale * factor, 50));
      updateStatus();
      redraw();
    }

    function resetView() {
      scale = 4;
      offsetX = canvas.width / 2;
      offsetY = canvas.height / 2;
      updateStatus();
      redraw();
    }

    // --- TRACK SMOOTHING ---
    function smoothTrackPoints(points, smoothness = 0.3, maxAngle = 60) {
      if (points.length < 3) return points;

      const smoothedPoints = [points[0]];
      const maxAngleRad = Math.PI * maxAngle / 180;

      for (let i = 1; i < points.length - 1; i++) {
        const prev = points[i - 1];
        const current = points[i];
        const next = points[i + 1];

        const v1 = { x: current.x - prev.x, z: current.z - prev.z };
        const v2 = { x: next.x - current.x, z: next.z - current.z };
        const mag1 = Math.sqrt(v1.x * v1.x + v1.z * v1.z);
        const mag2 = Math.sqrt(v2.x * v2.x + v2.z * v2.z);

        if (mag1 > 0 && mag2 > 0) {
          const dot = (v1.x * v2.x + v1.z * v2.z) / (mag1 * mag2);
          const angle = Math.acos(Math.max(-1, Math.min(1, dot)));

          if (angle > maxAngleRad) {
            const numIntermediatePoints = Math.ceil(angle / maxAngleRad) * 2;

            for (let j = 1; j <= numIntermediatePoints; j++) {
              const t = j / (numIntermediatePoints + 1);
              const smoothPoint = {
                x: prev.x + (current.x - prev.x) * t,
                z: prev.z + (current.z - prev.z) * t
              };
              smoothedPoints.push(smoothPoint);
            }

            smoothedPoints.push(current);

            for (let j = 1; j <= numIntermediatePoints; j++) {
              const t = j / (numIntermediatePoints + 1);
              const smoothPoint = {
                x: current.x + (next.x - current.x) * t,
                z: current.z + (next.z - current.z) * t
              };
              smoothedPoints.push(smoothPoint);
            }
          } else {
            smoothedPoints.push(current);
          }
        } else {
          smoothedPoints.push(current);
        }
      }

      smoothedPoints.push(points[points.length - 1]);
      return smoothedPoints;
    }

    function smoothTrack() {
      if (points.length < 3) {
        alert('Need at least 3 points to smooth track');
        return;
      }
      points = smoothTrackPoints(points, 0.3, 45);
      updateSmoothedPoints();
      redraw();
      updateStatus();
    }

    function toggleSmoothing() {
      enableSmoothing = !enableSmoothing;
      updateSmoothedPoints();
      redraw();
      updateStatus();
    }

    function toggleSnap() {
      enableSnap = !enableSnap;
      updateStatus();
    }

    function updateSmoothedPoints() {
      if (enableSmoothing && points.length >= 3) {
        smoothedPoints = smoothTrackPoints(points, 0.3, 60);
      } else {
        smoothedPoints = [...points];
      }
    }

    // --- TRACK STORAGE ---
    function getTrackNames() {
      try {
        return JSON.parse(localStorage.getItem('trackNames')) || ['Monza Standard'];
      } catch (e) {
        return ['Monza Standard'];
      }
    }

    function saveTrack() {
      const trackName = document.getElementById('saveInput').value.trim();
      if (!trackName || points.length < 3) {
        alert('Please enter a name and add at least 3 points.');
        return;
      }

      localStorage.setItem(`trackData_${trackName}`, JSON.stringify(
        points.map(p => ({ x: p.x.toFixed(1), z: p.z.toFixed(1) }))
      ));

      const trackNames = getTrackNames().filter(name => name !== 'Monza Standard');
      if (!trackNames.includes(trackName)) {
        trackNames.push(trackName);
        localStorage.setItem('trackNames', JSON.stringify(trackNames));
      }
      alert(`Track '${trackName}' saved successfully!`);
      loadTrackList();
    }

    function loadTrack(name) {
      if (name === 'Monza Standard') {
        points = [
          { x: 108.5, z: 57.9 }, { x: 102.0, z: -30.0 }, { x: 59.0, z: -48.5 },
          { x: 19.0, z: -47.0 }, { x: -18.0, z: -45.0 }, { x: -41.0, z: -30.0 },
          { x: -56.0, z: 0.0 }, { x: -53.0, z: 34.0 }, { x: -31.0, z: 55.0 },
          { x: 15.0, z: 58.0 }, { x: 52.0, z: 52.0 }, { x: 82.0, z: 38.0 },
          { x: 108.0, z: 57.9 }
        ];
      } else {
        const data = localStorage.getItem(`trackData_${name}`);
        if (data) {
          points = JSON.parse(data).map(p => ({ x: parseFloat(p.x), z: parseFloat(p.z) }));
        } else {
          alert(`Track '${name}' not found.`);
          return;
        }
      }
      document.getElementById('saveInput').value = name;
      updateSmoothedPoints();
      redraw();
      updateStatus();
    }

    function loadTrackList() {
      const trackNames = getTrackNames();
      const select = document.getElementById('loadSelect');
      select.innerHTML = '<option value="">Select Track...</option>';
      trackNames.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
      });
    }

    function loadSelectedTrack() {
      const select = document.getElementById('loadSelect');
      const selectedTrackName = select.value;
      if (selectedTrackName) {
        loadTrack(selectedTrackName);
      }
    }

    // --- EDITOR FUNCTIONS ---
    function setMode(newMode) {
      mode = newMode;
      document.getElementById('addBtn').classList.toggle('active', newMode === 'add');
      document.getElementById('editBtn').classList.toggle('active', newMode === 'edit');
      document.getElementById('panBtn').classList.toggle('active', newMode === 'pan');
      document.getElementById('deleteBtn').classList.toggle('active', newMode === 'delete');

      canvas.style.cursor =
        newMode === 'add' ? 'crosshair' :
          newMode === 'edit' ? 'grab' :
            newMode === 'pan' ? 'move' :
              newMode === 'delete' ? 'not-allowed' : 'default';

      updateStatus();
    }

    function worldToScreen(x, z) {
      return {
        x: offsetX + x * scale,
        y: offsetY - z * scale
      };
    }

    function screenToWorld(x, y) {
      return {
        x: (x - offsetX) / scale,
        z: (offsetY - y) / scale
      };
    }

    function drawPoint(x, z, isDragging = false, isControlPoint = true) {
      const screen = worldToScreen(x, z);
      ctx.beginPath();
      ctx.arc(screen.x, screen.y, isControlPoint ? 8 : 4, 0, Math.PI * 2);
      ctx.fillStyle = isControlPoint ?
        (isDragging ? '#ff0' : '#fff') :
        (isDragging ? '#0ff' : '#888');
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawCurve() {
      if (smoothedPoints.length < 2) return;

      // Draw smoothed curve
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      const first = worldToScreen(smoothedPoints[0].x, smoothedPoints[0].z);
      ctx.moveTo(first.x, first.y);

      for (let i = 1; i < smoothedPoints.length; i++) {
        const screen = worldToScreen(smoothedPoints[i].x, smoothedPoints[i].z);
        ctx.lineTo(screen.x, screen.y);
      }
      ctx.stroke();

      // Draw original control points line
      if (points.length >= 2) {
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        const firstCtrl = worldToScreen(points[0].x, points[0].z);
        ctx.moveTo(firstCtrl.x, firstCtrl.y);

        for (let i = 1; i < points.length; i++) {
          const screen = worldToScreen(points[i].x, points[i].z);
          ctx.lineTo(screen.x, screen.y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    function drawGrid() {
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      const gridSize = 50;
      const worldWidth = canvas.width / scale;
      const worldHeight = canvas.height / scale;

      for (let x = -worldWidth; x <= worldWidth; x += gridSize) {
        ctx.beginPath();
        const screen = worldToScreen(x, 0);
        ctx.moveTo(screen.x, 0);
        ctx.lineTo(screen.x, canvas.height);
        ctx.stroke();
      }
      for (let z = -worldHeight; z <= worldHeight; z += gridSize) {
        ctx.beginPath();
        const screen = worldToScreen(0, z);
        ctx.moveTo(0, screen.y);
        ctx.lineTo(canvas.width, screen.y);
        ctx.stroke();
      }
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawCurve();

      // Draw smoothed points (smaller)
      if (enableSmoothing) {
        smoothedPoints.forEach((p, i) => {
          if (i > 0 && i < smoothedPoints.length - 1) {
            drawPoint(p.x, p.z, false, false);
          }
        });
      }

      // Draw control points (larger)
      points.forEach((p, i) => drawPoint(p.x, p.z, i === draggingIndex, true));
    }

    function updateStatus() {
      const status = document.getElementById('status');
      const modeText =
        mode === 'add' ? 'Add Points' :
          mode === 'edit' ? 'Edit Points' :
            mode === 'pan' ? 'Pan View' : 'Delete Points';

      status.innerHTML = `Points: ${points.length} | Mode: ${modeText} | Zoom: ${scale.toFixed(1)}x | Smoothing: ${enableSmoothing ? 'Enabled' : 'Disabled'}`;
    }

    // --- MOUSE EVENT HANDLERS ---
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);

      if (mode === 'pan') {
        isPanning = true;
        panStartX = mouseX;
        panStartY = mouseY;
        canvas.style.cursor = 'grabbing';
        return;
      }

      if (mode === 'add') {
        if (enableSnap) {
          world.x = Math.round(world.x / 5) * 5;
          world.z = Math.round(world.z / 5) * 5;
        }
        points.push({ x: world.x, z: world.z });
        updateSmoothedPoints();
      } else if (mode === 'edit') {
        draggingIndex = -1;
        for (let i = 0; i < points.length; i++) {
          const screen = worldToScreen(points[i].x, points[i].z);
          const dx = mouseX - screen.x;
          const dy = mouseY - screen.y;
          if (Math.sqrt(dx * dx + dy * dy) < 10) {
            draggingIndex = i;
            isDragging = true;
            canvas.style.cursor = 'grabbing';
            break;
          }
        }
      } else if (mode === 'delete') {
        for (let i = points.length - 1; i >= 0; i--) {
          const screen = worldToScreen(points[i].x, points[i].z);
          const dx = mouseX - screen.x;
          const dy = mouseY - screen.y;
          if (Math.sqrt(dx * dx + dy * dy) < 10) {
            points.splice(i, 1);
            updateSmoothedPoints();
            break;
          }
        }
      }

      redraw();
      updateStatus();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);

      // Update tooltip
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 10) + 'px';
      tooltip.style.top = (e.clientY + 10) + 'px';
      tooltip.textContent = `X: ${world.x.toFixed(1)}, Z: ${world.z.toFixed(1)}`;

      if (mode === 'pan' && isPanning) {
        offsetX += mouseX - panStartX;
        offsetY += mouseY - panStartY;
        panStartX = mouseX;
        panStartY = mouseY;
        redraw();
        return;
      }

      if (mode === 'edit' && isDragging && draggingIndex !== -1) {
        if (enableSnap) {
          world.x = Math.round(world.x / 5) * 5;
          world.z = Math.round(world.z / 5) * 5;
        }

        // Snap last point to first for loop closure
        if (draggingIndex === points.length - 1 && points.length > 1) {
          const dx = world.x - points[0].x;
          const dz = world.z - points[0].z;
          if (Math.sqrt(dx * dx + dz * dz) < 2) {
            points[draggingIndex].x = points[0].x;
            points[draggingIndex].z = points[0].z;
          } else {
            points[draggingIndex].x = world.x;
            points[draggingIndex].z = world.z;
          }
        } else {
          points[draggingIndex].x = world.x;
          points[draggingIndex].z = world.z;
        }

        updateSmoothedPoints();
        redraw();
      }
    });

    canvas.addEventListener('mouseup', () => {
      if (isDragging || isPanning) {
        isDragging = false;
        isPanning = false;
        canvas.style.cursor =
          mode === 'add' ? 'crosshair' :
            mode === 'edit' ? 'grab' :
              mode === 'pan' ? 'move' :
                mode === 'delete' ? 'not-allowed' : 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
      isPanning = false;
      tooltip.style.display = 'none';
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 1 / 1.1 : 1.1;
      zoom(zoomFactor);
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (mode === 'edit') {
        setMode('delete');
        setTimeout(() => setMode('edit'), 100);
      }
    });

    // --- UTILITY FUNCTIONS ---
    function clearPoints() {
      points = [];
      smoothedPoints = [];
      redraw();
      updateStatus();
    }

    function exportPoints() {
      if (points.length === 0) {
        alert('Add some points first!');
        return;
      }
      const jsCode = `// Generated Track Points
const trackPoints = [
  ${points.map(p => `new THREE.Vector3(${p.x.toFixed(1)}, 0, ${p.z.toFixed(1)})`).join(',\n  ')}
];

// For TrackBuilder.js use:
loadTrackDefinition('Custom Track');
generateTrackMesh(scene);`;
      document.getElementById('output').value = jsCode;
    }

    // Initialize
    loadTrackList();
    loadTrack('Monza Standard');
    updateSmoothedPoints();
    redraw();
    updateStatus();

    // Expose functions globally
    window.setMode = setMode;
    window.clearPoints = clearPoints;
    window.exportPoints = exportPoints;
    window.saveTrack = saveTrack;
    window.loadTrackList = loadTrackList;
    window.loadSelectedTrack = loadSelectedTrack;
    window.zoom = zoom;
    window.resetView = resetView;
    window.smoothTrack = smoothTrack;
    window.toggleSmoothing = toggleSmoothing;
    window.toggleSnap = toggleSnap;
  </script>
</body>

</html>